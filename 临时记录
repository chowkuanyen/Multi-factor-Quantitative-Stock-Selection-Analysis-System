import akshare as ak
import pandas as pd
from datetime import datetime, timedelta
import time
import os
from concurrent.futures import ThreadPoolExecutor, as_completed
import warnings
from typing import Callable, Dict, Any, List
import pandas_ta as ta
import numpy as np
import xlsxwriter

# 忽略 pandas 的 SettingWithCopyWarning
warnings.filterwarnings('ignore', category=pd.errors.SettingWithCopyWarning)


# ==============================================================================
# 核心工具函数和配置
# ==============================================================================
class Config:
    """程序配置类"""

    def __init__(self):
        self.HOME_DIRECTORY = os.path.expanduser('~')
        self.SAVE_DIRECTORY = os.path.join(self.HOME_DIRECTORY, 'Downloads', 'CoreNews_Reports')
        self.TEMP_DATA_DIRECTORY = os.path.join(self.SAVE_DIRECTORY, 'ShareData')
        self.DATA_FETCH_RETRIES = 3
        self.DATA_FETCH_DELAY = 5  
        self.MAX_WORKERS = 15
        self.CODE_ALIASES = {'代码': '股票代码', '证券代码': '股票代码', '股票代码': '股票代码'}
        self.NAME_ALIASES = {'名称': '股票简称', '股票名称': '股票简称', '股票简称': '股票简称', '简称': '股票简称',
                             '简': '股票简称', '证券名称': '股票简称'}
        self.PRICE_ALIASES = {'最新价': '最新价', '现价': '最新价', '当前价格': '最新价', '今收盘': '最新价',
                              '收盘': '最新价', '收盘价': '最新价'}


def format_stock_code(code: str) -> str:
    """根据股票代码的开头数字，添加市场前缀。"""
    code_str = str(code).zfill(6)
    if code_str.startswith('6'):
        return 'sh' + code_str
    elif code_str.startswith(('0', '3')):
        return 'sz' + code_str
    elif code_str.startswith(('4', '8')):
        return 'bj' + code_str
    return code_str


# ==============================================================================
# 核心分析类
# ==============================================================================
class StockAnalyzer:

    def __init__(self):
        self.config = Config()
        self.today_str = datetime.now().strftime("%Y%m%d")
        self.temp_dir = self.config.TEMP_DATA_DIRECTORY
        os.makedirs(self.temp_dir, exist_ok=True)
        os.makedirs(self.config.SAVE_DIRECTORY, exist_ok=True)
        self.executor = ThreadPoolExecutor(max_workers=self.config.MAX_WORKERS)
        self.start_time = time.time()

    def _get_file_path(self, base_name: str, cleaned: bool = False) -> str:
        suffix = "_经清洗" if cleaned else ""
        file_name = f"{base_name}{suffix}_{self.today_str}.txt"
        return os.path.join(self.temp_dir, file_name)

    def _load_data_from_cache(self, file_path: str) -> pd.DataFrame:
        if os.path.exists(file_path):
            try:
                df = pd.read_csv(file_path, sep='|', encoding='utf-8', dtype={'股票代码': str})
                print(f"  - 发现缓存，加载: {os.path.basename(file_path)}")
                return df
            except Exception as e:
                print(f"[WARN] 加载缓存 {os.path.basename(file_path)} 失败: {e}")
        return pd.DataFrame()

    def _save_data_to_cache(self, df: pd.DataFrame, file_path: str):
        try:
            df.to_csv(file_path, sep='|', index=False, encoding='utf-8')
        except Exception as e:
            print(f"[ERROR] 保存数据到缓存 {os.path.basename(file_path)} 失败: {e}")

    def _safe_ak_fetch(self, fetch_func: Callable, file_base_name: str, **kwargs: Any) -> pd.DataFrame:
        cleaned_file_path = self._get_file_path(file_base_name, cleaned=True)
        cached_df = self._load_data_from_cache(cleaned_file_path)
        if not cached_df.empty:
            return cached_df

        df = pd.DataFrame()
        for i in range(self.config.DATA_FETCH_RETRIES):
            try:
                print(f"  - 正在尝试第 {i + 1}/{self.config.DATA_FETCH_RETRIES} 次获取数据: {file_base_name}...")
                df = fetch_func(**kwargs)
                if df is not None and not df.empty:
                    break
                time.sleep(self.config.DATA_FETCH_DELAY)
            except Exception as e:
                print(f"[ERROR] 获取 {file_base_name} 出错: {e}")
                time.sleep(self.config.DATA_FETCH_DELAY)

        if df.empty:
            return pd.DataFrame()

        cleaned_df = self._clean_and_standardize(df, file_base_name)
        if not cleaned_df.empty:
            self._save_data_to_cache(cleaned_df, cleaned_file_path)
        return cleaned_df

    def _clean_and_standardize(self, df: pd.DataFrame, df_name: str) -> pd.DataFrame:
        if df.empty: return df
        for old, new in self.config.CODE_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)
        for old, new in self.config.NAME_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)
        for old, new in self.config.PRICE_ALIASES.items():
            if old in df.columns: df.rename(columns={old: new}, inplace=True)

        if '股票代码' not in df.columns: return pd.DataFrame()
        df.dropna(subset=['股票代码'], inplace=True)
        df.drop_duplicates(subset=['股票代码'], inplace=True)
        df['股票代码'] = df['股票代码'].astype(str).str.zfill(6)
        if '最新价' in df.columns:
            df['最新价'] = pd.to_numeric(df['最新价'], errors='coerce')
        
        if '股票简称' not in df.columns:
            cleaned_df = df.copy()
        else:
            cleaned_df = df[~df['股票简称'].str.contains('ST|st|退市|bj|BJ', case=False, na=False)].copy()
        return cleaned_df

    def _get_all_raw_data(self) -> Dict[str, pd.DataFrame]:
        print("\n>>> 正在初始化数据获取...")
        data = {
            'spot_data_all': self._safe_ak_fetch(ak.stock_zh_a_spot, "A股实时行情"),
            'main_report_raw': self._safe_ak_fetch(ak.stock_profit_forecast_em, "主力研报盈利预测"),
            'financial_abstract_raw': self._safe_ak_fetch(ak.stock_financial_abstract, "财务摘要数据"),
            'market_fund_flow_raw': self._safe_ak_fetch(ak.stock_fund_flow_individual, "5日市场资金流向", symbol="5日排行"),
            'market_fund_flow_raw_10': self._safe_ak_fetch(ak.stock_fund_flow_individual, "10日市场资金流向", symbol="10日排行"),
            'market_fund_flow_raw_20': self._safe_ak_fetch(ak.stock_fund_flow_individual, "20日市场资金流向", symbol="20日排行"),
            'strong_stocks_raw': self._safe_ak_fetch(ak.stock_zt_pool_strong_em, "强势股池", date=datetime.now().strftime('%Y%m%d')),
            'consecutive_rise_raw': self._safe_ak_fetch(ak.stock_rank_lxsz_ths, "连续上涨"),
            'ljqs_raw': self._safe_ak_fetch(ak.stock_rank_ljqs_ths, "量价齐升"),
            'cxfl_raw': self._safe_ak_fetch(ak.stock_rank_cxfl_ths, "持续放量"),
        }
        data['xstp_10_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破10日均线", symbol="10日均线")
        data['xstp_30_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破30日均线", symbol="30日均线")
        data['xstp_60_raw'] = self._safe_ak_fetch(ak.stock_rank_xstp_ths, "向上突破60日均线", symbol="30日均线")

        print("\n>>> 正在获取行业板块信息...")
        industry_board_df = ak.stock_board_industry_name_em()
        data['top_industry_cons_df'] = self._get_top_industry_constituents(industry_board_df)
        data['industry_board_df'] = industry_board_df
        return data

    def _safe_fetch_constituents(self, symbol: str) -> pd.DataFrame:
        for i in range(self.config.DATA_FETCH_RETRIES):
            try:
                df = ak.stock_board_industry_cons_em(symbol=symbol)
                if df is not None and not df.empty: return df
                time.sleep(self.config.DATA_FETCH_DELAY)
            except Exception:
                time.sleep(self.config.DATA_FETCH_DELAY)
        return pd.DataFrame()

    def _get_top_industry_constituents(self, industry_board_df: pd.DataFrame) -> pd.DataFrame:
        if industry_board_df.empty or '板块名称' not in industry_board_df.columns:
            return pd.DataFrame()

        cache_name = "TopIndustryConstituents_经清洗"
        cleaned_file_path = self._get_file_path(cache_name, cleaned=True)
        cached_df = self._load_data_from_cache(cleaned_file_path)
        if not cached_df.empty: return cached_df

        top_industries = industry_board_df.sort_values(by='涨跌幅', ascending=False).head(10)
        all_constituents = []
        future_to_industry = {
            self.executor.submit(self._safe_fetch_constituents, symbol=row['板块名称']): row['板块名称']
            for _, row in top_industries.iterrows()
        }

        for future in as_completed(future_to_industry):
            industry_name = future_to_industry[future]
            try:
                df = future.result()
                if df is not None and not df.empty:
                    df.rename(columns={'代码': '股票代码'}, inplace=True)
                    df['股票代码'] = df['股票代码'].astype(str).str.zfill(6)
                    df['所属板块'] = industry_name
                    all_constituents.append(df[['股票代码', '所属板块']].drop_duplicates())
            except Exception as e:
                print(f"[ERROR] 获取 {industry_name} 成分股失败: {e}")

        if all_constituents:
            final_df = pd.concat(all_constituents, ignore_index=True).drop_duplicates(subset=['股票代码'])
            self._save_data_to_cache(final_df, cleaned_file_path)
            return final_df
        return pd.DataFrame()

    def _fetch_hist_data_parallel(self, codes: List[str], days: int) -> pd.DataFrame:
        print(f"\n正在下载 {len(codes)} 只股票的历史数据...")
        end_date = datetime.now()
        start_date = end_date - timedelta(days=days)
        start_date_str = start_date.strftime("%Y%m%d")
        end_date_str = end_date.strftime("%Y%m%d")

        cache_name = f"MACD_hist_data_cache_{len(codes)}"
        file_path = self._get_file_path(cache_name, cleaned=True)
        cached_df = self._load_data_from_cache(file_path)
        if not cached_df.empty: return cached_df

        all_data = []
        future_to_code = {
            self.executor.submit(ak.stock_zh_a_hist_tx, symbol=format_stock_code(code), 
                                 start_date=start_date_str, end_date=end_date_str, adjust="hfq"): code
            for code in codes
        }

        for future in as_completed(future_to_code):
            code = future_to_code[future]
            try:
                df = future.result()
                if df is not None and not df.empty:
                    df.rename(columns={'date': 'date', '日期': 'date', 'open': 'open', '开盘': 'open',
                                       'close': 'close', '收盘': 'close', 'high': 'high', '最高': 'high',
                                       'low': 'low', '最低': 'low', 'volume': 'volume', '成交量': 'volume'}, 
                               inplace=True, errors='ignore')
                    df['股票代码'] = code
                    if 'date' in df.columns:
                        df['date'] = pd.to_datetime(df['date']).dt.strftime('%Y-%m-%d')
                    all_data.append(df[['date', 'open', 'close', 'high', 'low', 'volume', '股票代码']])
            except Exception:
                pass

        if all_data:
            merged_df = pd.concat(all_data, ignore_index=True)
            self._save_data_to_cache(merged_df, file_path)
            return merged_df
        return pd.DataFrame()

    def _custom_macd(self, df: pd.DataFrame) -> pd.DataFrame:
        if 'close' not in df.columns: return df
        close = df['close']
        macd_periods = {'12269': (12, 26, 9), '6135': (6, 13, 5)}
        for name, (fast, slow, signal) in macd_periods.items():
            df[f'EMA_F_{name}'] = close.ewm(span=fast, adjust=False).mean()
            df[f'EMA_S_{name}'] = close.ewm(span=slow, adjust=False).mean()
            dif_col, dea_col = f'DIF_{name}', f'DEA_{name}'
            df[dif_col] = df[f'EMA_F_{name}'] - df[f'EMA_S_{name}']
            df[dea_col] = df[dif_col].ewm(span=signal, adjust=False).mean()
            is_cross = (df[dif_col] > df[dea_col]) & (df[dif_col].shift(1).fillna(0) <= df[dea_col].shift(1).fillna(0))
            df[f'MACD_{name}_SIGNAL_DETAIL'] = np.where(is_cross, np.where((df[dif_col] > 0) & (df[dea_col] > 0), '零轴上金叉', '零轴下金叉'), '')
            df.drop(columns=[f'EMA_F_{name}', f'EMA_S_{name}'], inplace=True, errors='ignore')
        return df

    def _calculate_macd_momentum(self, df: pd.DataFrame, dif_col: str, dea_col: str) -> str:
        if len(df) < 2: return "N/A"
        l_dif, l_dea, p_dif = df[dif_col].iloc[-1], df[dea_col].iloc[-1], df[dif_col].iloc[-2]
        change = l_dif - p_dif
        if l_dif >= l_dea:
            return "加速上涨 (红柱加长)" if change > 0 else "减速上涨 (红柱缩短)"
        else:
            return "加速下跌 (绿柱加长)" if change < 0 else "减速下跌 (绿柱缩短)"

    def _classify_cci_level(self, cci_value: float) -> str:
        if pd.isna(cci_value): return 'N/A'
        if cci_value > 200: return f'极度超买 ({cci_value:.2f})'
        elif cci_value >= 100: return f'强势超买 ({cci_value:.2f})'
        elif cci_value <= -200: return f'极度超卖 ({cci_value:.2f})'
        elif cci_value <= -100: return f'弱势超卖 ({cci_value:.2f})'
        return ''

    def _process_ta_signals(self, all_codes: List[str], hist_df_all: pd.DataFrame, spot_df: pd.DataFrame) -> Dict[str, pd.DataFrame]:
        ta_signals = {k: [] for k in ['MACD_12269', 'MACD_6135', 'KDJ', 'CCI', 'RSI', 'BOLL', 'MACD_DIF_MOMENTUM']}
        if hist_df_all.empty: return {k: pd.DataFrame() for k in ta_signals.keys()}
        hist_df_all.sort_values(['股票代码', 'date'], inplace=True)

        for code in all_codes:
            df = hist_df_all[hist_df_all['股票代码'] == code].copy()
            if len(df) < 30: continue
            for col in ['close', 'open', 'high', 'low']: df[col] = pd.to_numeric(df[col], errors='coerce')
            df.dropna(subset=['close'], inplace=True)
            
            try:
                df = self._custom_macd(df)
                l_row = df.iloc[-1]
                ta_signals['MACD_DIF_MOMENTUM'].append({
                    '股票代码': code, 'MACD_12269_DIF': l_row.get('DIF_12269', 0),
                    'MACD_12269_动能': self._calculate_macd_momentum(df, 'DIF_12269', 'DEA_12269'),
                    'MACD_6135_DIF': l_row.get('DIF_6135', 0),
                    'MACD_6135_动能': self._calculate_macd_momentum(df, 'DIF_6135', 'DEA_6135'),
                })
                for p in ['12269', '6135']:
                    sig = l_row[f'MACD_{p}_SIGNAL_DETAIL']
                    if sig: ta_signals[f'MACD_{p}'].append({'股票代码': code, f'MACD_{p}_Signal': sig})

                df.ta.stoch(append=True, close='close', high='high', low='low')
                k_cols = [c for c in df.columns if 'STOCHk_' in c]
                if k_cols:
                    k_col, d_col = k_cols[0], [c for c in df.columns if 'STOCHd_' in c][0]
                    df['KDJ_J'] = 3 * df[k_col] - 2 * df[d_col]
                    l_k, l_j, p_j = df[k_col].iloc[-1], df['KDJ_J'].iloc[-1], df['KDJ_J'].iloc[-2]
                    is_cross = (df[k_col] > df[d_col]).iloc[-1] and (df[k_col].shift(1) <= df[d_col].shift(1)).iloc[-1]
                    if p_j < 0 and l_j > 5 and is_cross:
                        ta_signals['KDJ'].append({'股票代码': code, 'KDJ_Signal': f"极值J线反转 (K={l_k:.1f}, J={l_j:.1f})"})

                df.ta.cci(append=True)
                cci_cols = [c for c in df.columns if 'CCI_' in c]
                if cci_cols:
                    cci_sig = self._classify_cci_level(df[cci_cols[0]].iloc[-1])
                    if cci_sig: ta_signals['CCI'].append({'股票代码': code, 'CCI_Signal': cci_sig})

                df.ta.rsi(append=True)
                rsi_cols = [c for c in df.columns if 'RSI_' in c]
                if rsi_cols and df[rsi_cols[0]].iloc[-1] < 30:
                    ta_signals['RSI'].append({'股票代码': code, 'RSI_Signal': f"超卖低位 ({df[rsi_cols[0]].iloc[-1]:.2f})"})

                df.ta.bbands(append=True, length=20, std=2)
                b_cols = [c for c in df.columns if 'BBL_' in c]
                if b_cols:
                    df['BW'] = (df[[c for c in df.columns if 'BBU_' in c][0]] - df[b_cols[0]]) / df['close']
                    if df['BW'].iloc[-5:].mean() < df['BW'].mean():
                        ta_signals['BOLL'].append({'股票代码': code, 'BOLL_Signal': '低波/缩口'})

            except Exception: continue

        return {k: pd.DataFrame(v) for k, v in ta_signals.items()}

    def _process_xstp_and_filter(self, raw_data: Dict[str, pd.DataFrame], spot_df: pd.DataFrame) -> pd.DataFrame:
        p10, p30, p60 = raw_data['xstp_10_raw'], raw_data['xstp_30_raw'], raw_data['xstp_60_raw']
        merged = pd.concat([p10[['股票代码', '股票简称']], p30[['股票代码', '股票简称']], p60[['股票代码', '股票简称']]]).drop_duplicates('股票代码')
        for d, n in zip([p10, p30, p60], [10, 30, 60]):
            merged = pd.merge(merged, d[['股票代码', '最新价']].rename(columns={'最新价': f'{n}日线'}), on='股票代码', how='left')
        merged = pd.merge(merged, spot_df[['股票代码', '最新价']], on='股票代码', how='left')
        for c in ['最新价', '10日线', '30日线', '60日线']: merged[c] = pd.to_numeric(merged[c], errors='coerce')
        
        filtered = merged[(merged['最新价'] > merged['10日线']) & ((merged['10日线'] > merged['30日线'].fillna(-1)) | (merged['30日线'] > merged['60日线'].fillna(-1)))].copy()
        filtered['完全多头排列'] = filtered.apply(lambda r: '是' if r['10日线'] > r['30日线'] > r['60日线'] else '否', axis=1)
        return filtered.rename(columns={'最新价': '当前价格', '10日线': '10日均线最新价', '30日线': '30日均线最新价', '60日线': '60日均线最新价'}).fillna('N/A')

    def _consolidate_data(self, processed_data: Dict[str, pd.DataFrame]) -> pd.DataFrame:
        print("\n>>> 正在汇总所有数据和信号...")
        all_codes = set()
        sources = ['processed_main_report', 'processed_xstp_df', 'market_fund_flow_raw', 'strong_stocks_raw', 
                   'consecutive_rise_raw', 'ljqs_raw', 'cxfl_raw', 'MACD_12269', 'MACD_6135', 'KDJ', 'CCI', 'RSI', 'BOLL']
        for s in sources:
            df = processed_data.get(s, pd.DataFrame())
            if not df.empty and '股票代码' in df.columns: all_codes.update(df['股票代码'].unique())
        
        if not all_codes: return pd.DataFrame()
        final_df = pd.DataFrame(list(all_codes), columns=['股票代码'])
        final_df['股票代码'] = final_df['股票代码'].astype(str)

        spot_df = processed_data.get('spot_data_all', pd.DataFrame())
        if not spot_df.empty:
            name_map = spot_df[['股票代码', '股票简称', '最新价']].drop_duplicates('股票代码')
            final_df = pd.merge(final_df, name_map, on='股票代码', how='left')

        # === [新增指标]：判断是否在前十行业板块 ===
        top_ind_df = processed_data.get('top_industry_cons_df', pd.DataFrame())
        if not top_ind_df.empty:
            top_codes = set(top_ind_df['股票代码'].astype(str).unique())
            final_df['热门行业'] = final_df['股票代码'].apply(lambda x: '是' if x in top_codes else '否')
        else:
            final_df['热门行业'] = '否'

        # 合并主力研报
        rep = processed_data['processed_main_report']
        if not rep.empty:
            rep = rep[['股票代码', '机构投资评级(近六个月)-买入']].rename(columns={'机构投资评级(近六个月)-买入': '研报买入次数'})
            final_df = pd.merge(final_df, rep, on='股票代码', how='left')
        final_df['研报买入次数'] = final_df['研报买入次数'].fillna(0).astype(int)

        # 合并均线
        xstp = processed_data['processed_xstp_df']
        if not xstp.empty:
            cols = ['股票代码', '完全多头排列', '10日均线最新价', '30日均线最新价', '60日均线最新价']
            final_df = pd.merge(final_df, xstp[cols], on='股票代码', how='left')
        final_df['完全多头排列'] = final_df['完全多头排列'].fillna('否')

        # 合并排名数据
        for tag, col, name in [('market_fund_flow_raw', '资金流入净额', '5日资金流入'),
                               ('market_fund_flow_raw_10', '资金流入净额', '10日资金流入'),
                               ('market_fund_flow_raw_20', '资金流入净额', '20日资金流入'),
                               ('consecutive_rise_raw', '连涨天数', '连涨天数'),
                               ('cxfl_raw', '放量天数', '放量天数')]:
            df = processed_data.get(tag, pd.DataFrame())
            if not df.empty and '股票代码' in df.columns:
                final_df = pd.merge(final_df, df[['股票代码', col]].drop_duplicates('股票代码'), on='股票代码', how='left')
                final_df.rename(columns={col: name}, inplace=True)

        final_df['强势股'] = final_df['股票代码'].apply(lambda x: '是' if x in processed_data['strong_stocks_raw']['股票代码'].tolist() else '否')
        final_df['量价齐升'] = final_df['股票代码'].apply(lambda x: '是' if x in processed_data['ljqs_raw']['股票代码'].tolist() else '否')

        # 合并 TA
        for k in ['MACD_12269', 'MACD_6135', 'KDJ', 'CCI', 'RSI', 'BOLL']:
            df = processed_data.get(k, pd.DataFrame())
            if not df.empty:
                col_name = f"{k}_Signal" if "Signal" not in df.columns else k
                final_df = pd.merge(final_df, df[['股票代码', df.columns[1]]], on='股票代码', how='left')
        
        # 合并动能
        mom = processed_data.get('MACD_DIF_MOMENTUM', pd.DataFrame())
        if not mom.empty: final_df = pd.merge(final_df, mom, on='股票代码', how='left')

        # 信号过滤
        def has_any_signal(row):
            return (row['研报买入次数'] > 0 or row['完全多头排列'] == '是' or row['强势股'] == '是' or 
                    row['量价齐升'] == '是' or row['热门行业'] == '是' or  # <== 加入热门行业判断
                    any(str(row.get(c, '')) != '' for c in ['MACD_12269_Signal', 'MACD_6135_Signal', 'KDJ_Signal', 'CCI_Signal']))

        final_df = final_df[final_df.apply(has_any_signal, axis=1)].copy()
        final_df.sort_values(['研报买入次数', '热门行业', '连涨天数'], ascending=[False, False, False], inplace=True)
        final_df.reset_index(drop=True, inplace=True)
        final_df.insert(0, '序号', range(1, len(final_df) + 1))
        final_df['股票链接'] = final_df['股票代码'].apply(lambda x: f"https://hybrid.gelonghui.com/stock-check/{format_stock_code(x)}")

        # 最终列定义
        base = ['序号', '股票代码', '股票简称', '最新价']
        sigs = ['强势股', '量价齐升', '热门行业', '连涨天数', '放量天数', 'MACD_12269_Signal', 'MACD_12269_动能', 'MACD_6135_Signal', 'KDJ_Signal', 'CCI_Signal']
        reps = ['研报买入次数', '完全多头排列', '10日均线最新价', '5日资金流入', '股票链接']
        cols = [c for c in base + sigs + reps if c in final_df.columns]
        return final_df[cols].fillna('')

    def _generate_report(self, sheets_data: Dict[str, pd.DataFrame]):
        path = os.path.join(self.config.SAVE_DIRECTORY, f"股票筛选报告_{self.today_str}.xlsx")
        try:
            with pd.ExcelWriter(path, engine='xlsxwriter') as writer:
                for name, df in sheets_data.items():
                    if df.empty: continue
                    df.to_excel(writer, sheet_name=name[:31], index=False)
                    ws = writer.sheets[name[:31]]
                    for i, col in enumerate(df.columns):
                        ws.set_column(i, i, max(len(str(col)), 12))
            print(f"  - 报告已生成: {path}")
        except Exception as e: print(f"[ERROR] 生成报告失败: {e}")

    def run(self):
        print(f"程序启动: {self.today_str}")
        try:
            raw_data = self._get_all_raw_data()
            spot_df = raw_data['spot_data_all']
            main_rep = raw_data['main_report_raw']
            
            # 基础过滤：主力研报买入 > 1 或 热门行业
            if not main_rep.empty:
                main_rep['机构投资评级(近六个月)-买入'] = pd.to_numeric(main_rep['机构投资评级(近六个月)-买入'], errors='coerce').fillna(0)
                filtered_rep = main_rep[main_rep['机构投资评级(近六个月)-买入'] > 1]
            else:
                filtered_rep = pd.DataFrame()

            all_codes = set(filtered_rep['股票代码'].tolist()) if not filtered_rep.empty else set()
            # 如果研报名单太少，补充热门行业的股票进入技术分析池
            if not raw_data['top_industry_cons_df'].empty:
                all_codes.update(raw_data['top_industry_cons_df']['股票代码'].tolist())
            
            if not all_codes and not spot_df.empty:
                all_codes = set(spot_df['股票代码'].head(500).tolist())

            hist_data = self._fetch_hist_data_parallel(list(all_codes), 90)
            ta_sigs = self._process_ta_signals(list(all_codes), hist_data, spot_df)
            xstp_df = self._process_xstp_and_filter(raw_data, spot_df)

            processed = {**raw_data, **ta_sigs, 'processed_xstp_df': xstp_df, 'processed_main_report': filtered_rep}
            report = self._consolidate_data(processed)
            
            self._generate_report({'数据汇总': report, '前十板块成分': raw_data['top_industry_cons_df'], '实时行情': spot_df})
        except Exception as e: print(f"流程异常: {e}")
        finally: print(f"耗时: {timedelta(seconds=time.time() - self.start_time)}")

if __name__ == "__main__":
    StockAnalyzer().run()
